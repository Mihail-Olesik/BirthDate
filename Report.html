<!DOCTYPE html>
<html>
<head>
	<title>Report</title>
</head>
<body>
<p style="text-align:justify"><strong>МЕХАНИЗМЫ УВЕДОМЛЕНИЙ И СИГНАЛИЗАЦИИ</strong></p>

<p style="text-align:justify">Способы оповещения пользователей. Сигнализация и подключение механизма уведомлений. Отложенная сигнализация.</p>

<p style="text-align:justify">Системные события. Типы широковещательных сообщений. Организация приема и обработки широковещательных сообщений. Принципы использования компонента BroadcastReceiver. Особенности применения объектов Intent Filter.</p>

<hr />
<p style="text-align:justify">Уведомления - один из самых простых способов сообщить своим пользователям о новых событиях или функциях в приложении и заставить пользователя снова открыть приложение. Существует 2 способа оповещения пользователей: когда программа отправляет push-уведомление и через онлайн сервис Firebase. Используя Firebase, можно отправлять уведомления всем пользователям или сегментам пользовательской базы, позволяя настраивать то, что получают пользователи, и поднять их интерес.</p>

<p style="text-align:justify">Технология push &mdash; один из способов распространения информации, когда данные поступают от поставщика к пользователю на основе установленных параметров. Пользователь же, в свою очередь, либо отвергает, либо принимает данные.</p>

<p style="text-align:justify">Для работы push-уведомлений используется четыре компонента:</p>

<ol>
	<li style="text-align: justify;">Сервер push-уведомлений (у каждой современной ОС есть свой сервер, у&nbsp;Android &mdash; FCM (Firebase Cloud Messaging)).</li>
	<li style="text-align: justify;">Сервер автора приложения, который посылает уведомления серверу push-уведомлений.</li>
	<li style="text-align: justify;">Постоянно работающая служба в операционной системе устройства, общающаяся с сервером push-уведомлений.</li>
	<li style="text-align: justify;">Приложение, поддерживающее push-уведомления.</li>
</ol>

<p style="text-align:justify">Предварительно разработчик приложения регистрирует свой сервер на сервере уведомлений ОС. После того как пользователь даёт разрешение приложению на получение уведомлений, приложение отправляет уникальный ID приложения и уникальный номер устройства на сервер уведомлений и регистрируется на этом сервере. Эти два уникальных номера образуют уникальный идентификатор. Затем этот идентификатор отправляется с сервера уведомлений на сервер владельца приложения.</p>

<p style="text-align:justify">Когда сервер автора приложения должен будет отправить уведомления клиентам, он формирует само сообщение и список уникальных идентификаторов и отправляет эти данные с помощью специального API на сервер уведомлений. Сервер уведомлений пересылает эти сообщения клиентам. Клиенты вправе как отбросить, так и принять эти данные.</p>

<p style="text-align:justify">Интервал пульса Android &ndash; это время, необходимое для доступа к серверам обмена сообщениями google для запуска push-уведомлений приложений. По умолчанию время в сети wi-fi составляет 15 минут, а в сетях 2G или 3G - 4 минут. Можно изменить интервал с помощью приложения по названию Heartbeat Interval с помощью приложения под названием Push Notifications Fixer.</p>

<p style="text-align:justify">AlarmManager имеет доступ к системе аварийной сигнализации. С помощью AlarmManager можно запланировать выполнение кода в будущем. Объект AlarmManager не может быть создан непосредственно, однако его можно получить, вызвав Context.getSystemService(Context.ALARM_SERVICE). AlarmManager всегда регистрируется в Intent. Когда срабатывает сигнал тревоги, намерение, зарегистрированное с помощью AlarmManager, передается системой автоматически. Это намерение запускает целевое приложение, если оно не запущено.</p>

<p style="text-align:justify">События &mdash; это полезный способ сбора данных о взаимодействии пользователя с интерактивными компонентами Приложений. Как нажатие кнопок или касание экрана и т. Д. Платформа Android поддерживает очередь событий в порядке &laquo;первым пришел &mdash; первым вышел&raquo; (FIFO). Вы можете зафиксировать эти события в своей программе и предпринять соответствующие действия в соответствии с требованиями.</p>

<p style="text-align:justify">Существуют следующие три понятия, связанные с управлением событиями в Android:</p>

<ul>
	<li style="text-align: justify;">Прослушиватели событий. Прослушиватель событий &mdash; это интерфейс в классе View, содержащий единственный метод обратного вызова. Эти методы будут вызываться платформой Android, когда представление, для которого зарегистрирован прослушиватель, запускается при взаимодействии пользователя с элементом в пользовательском интерфейсе.</li>
	<li style="text-align: justify;">Регистрация прослушивателей событий &mdash; регистрация событий &mdash; это процесс, с помощью которого обработчик событий регистрируется в прослушивателе событий, так что обработчик вызывается, когда прослушиватель событий запускает событие.</li>
	<li style="text-align: justify;">Обработчики событий &mdash; когда происходит событие, и мы регистрируем прослушиватель события для события, прослушиватель события вызывает обработчики событий, что является методом, который фактически обрабатывает событие.</li>
</ul>

<p style="text-align:justify">Android Broadcast Receiver - один из основных компонентов разработки приложений для Android. Приемник вещания является компонентом приложения для Android. С помощью этого компонента можно регистрировать получателей для любого события системного или прикладного уровня. Как только это событие произойдет, система Android уведомит зарегистрированных получателей о выполнении событий соответственно.</p>

<p style="text-align:justify">Получатели принимают широковещательные сообщения двух типов:</p>

<p style="text-align:justify">1. Обычные трансляции:</p>

<ul>
	<li style="text-align: justify;">Это асинхронные трансляции.</li>
	<li style="text-align: justify;">Приемники этого типа трансляций могут работать в любом порядке, а иногда и вместе.</li>
	<li style="text-align: justify;">Это эффективно.</li>
	<li style="text-align: justify;">Получатели не могут использовать результат.</li>
	<li style="text-align: justify;">Они не могут прервать включенные API.</li>
	<li style="text-align: justify;">Эти трансляции отправляются с помощью Context.sendBroadcast</li>
</ul>

<p style="text-align:justify">2. Заказные трансляции</p>

<ul>
	<li style="text-align: justify;">Это синхронные трансляции.</li>
	<li style="text-align: justify;">Одна трансляция доставляется на один приемник за раз.</li>
	<li style="text-align: justify;">Получатели могут использовать результат. Фактически, когда каждый получатель выполняет, результат передается следующему получателю.</li>
	<li style="text-align: justify;">Получатель может прервать трансляцию, и, следовательно, другие получатели не получат трансляцию.</li>
	<li style="text-align: justify;">Порядок получателей управляется и контролируется атрибутом android: priority в соответствующем фильтре намерений.</li>
	<li style="text-align: justify;">Если получатели будут иметь одинаковый приоритет, они могут работать в любом порядке.</li>
</ul>

<p style="text-align:justify">Преимущества широковещательного приемника:</p>

<ul>
	<li style="text-align: justify;">Приемник Broadcast пробуждает ваше приложение, встроенный код работает только тогда, когда ваше приложение запущено.</li>
	<li style="text-align: justify;">Нет пользовательского интерфейса, но можно запустить действие</li>
	<li style="text-align: justify;">Он имеет максимальный предел 10 секунд, не выполняет никаких асинхронных операций, которые могут занять больше времени, не выполняйте тяжелые операции с базой данных или сетевые операции в широковещательном приемнике.</li>
</ul>

<p style="text-align:justify">Широковещательное сообщение заключено в Intent объект, строка действия которого идентифицирует произошедшее событие (например android.intent .action.AIRPLANE_MODE). Намерение также может включать дополнительную информацию, объединенную в дополнительное поле. Например, намерение режима полета включает дополнительное логическое значение, которое указывает, включен ли режим полета.</p>

<p style="text-align:justify">Каждое широковещательное действие имеет связанное с ним постоянное поле. Например, значение константы ACTION_AIRPLANE_MODE_CHANGED является android.intent.action.AIRPLANE_MODE. Документация по каждому широковещательному действию доступна в соответствующем поле констант.</p>

<p style="text-align:justify">Приложения могут получать широковещательные сообщения двумя способами: через получателей, объявленных в манифесте, и получателей, зарегистрированных в контексте.</p>

<p style="text-align:justify">Система вещания является сообщение о том, что Android система посылает , когда происходит событие системы. Системные трансляции заключены в Intent объекты. Поле действия объекта намерения содержит сведения о событии, например android.intent.action.HEADSET_PLUG, которое отправляется при подключении или отключении проводной гарнитуры. Намерение также может содержать дополнительные данные о событии в дополнительном поле, например, boolean дополнительное, указывающее, подключена или отключена гарнитура.</p>

<p style="text-align:justify">Intent Filters - это выражение в файле манифеста приложения, которое указывает тип намерений, которые компонент хотел бы получить. Например, объявляя фильтр намерений для действия, вы позволяете другим приложениям напрямую начинать вашу деятельность с определенным намерением. Точно так же, если вы не объявляете фильтры намерений для действия, то оно может быть запущено только с явным намерением.</p>

<p style="text-align:justify">Intent представляет собой структуру данных, содержащую описание операции, которую следует выполнить. Одна из наиболее мощных функций Intent механизма в том, что вы можете асинхронно отправить сообщения другим Activity (активностям) или сервисам.</p>

<p style="text-align:justify">Типы Android Intent:</p>

<ol>
	<li style="text-align: justify;">Явное намерение (Explicit intent) явно определяет компонент по имени. Чаще всего в наших приложениях мы будем использовать явное намерение для запуска какого-то компонента. Суть Explicit intent в том, что вы знаете имя класса Activity или Service (сервиса), который нужно запустить. При использовании явного намерения система немедленно запускает компонент приложения, указанный в объекте Intent.</li>
	<li style="text-align: justify;">Неявное намерения (Implicit intent) не определяет конкретный компонент, а просто заявляет о некотором действии, позволяя компонентам других приложений его обработать. При создании неявного намерения Android система находит все возможные компоненты, которые могут обрабатывать заявленное действие, и предлагает выбрать одно из найденного списка.</li>
</ol>
</body>
</html>
